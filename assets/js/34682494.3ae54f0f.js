"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[5],{1871:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var t=i(4848),r=i(8453);const s={sidebar_position:4,slug:"/lab/03"},a="03 - Services",c={id:"lab/03/index",title:"03 - Services",description:"A Service is an application component that can perform long-running operations in the background. It does not provide a user interface. Once started, a service might continue running for some time, even after the user switches to another application.",source:"@site/docs/lab/03/index.md",sourceDirName:"lab/03",slug:"/lab/03",permalink:"/docs/lab/03",draft:!1,unlisted:!1,editUrl:"https://github.com/UPB-FILS-MDAD/upb-fils-mdad.github.io/edit/main/docs/lab/03/index.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,slug:"/lab/03"},sidebar:"tutorialSidebar",previous:{title:"02 - Intents",permalink:"/docs/lab/02"},next:{title:"04 - Persistent storage",permalink:"/docs/lab/04"}},o={},d=[{value:"The service lifecycle",id:"the-service-lifecycle",level:2},{value:"Services types",id:"services-types",level:2},{value:"Background services",id:"background-services",level:3},{value:"Starting a background service",id:"starting-a-background-service",level:4},{value:"Stoping a background service",id:"stoping-a-background-service",level:4},{value:"Running a task inside the service",id:"running-a-task-inside-the-service",level:4},{value:"Foreground services",id:"foreground-services",level:3},{value:"Starting a foreground service",id:"starting-a-foreground-service",level:4},{value:"Stoping a foreground service",id:"stoping-a-foreground-service",level:4},{value:"Updating data in the notification",id:"updating-data-in-the-notification",level:4},{value:"Bound services",id:"bound-services",level:3},{value:"Preparing bound service",id:"preparing-bound-service",level:4},{value:"Binding a service",id:"binding-a-service",level:4},{value:"Unbiding a service",id:"unbiding-a-service",level:4},{value:"Running a task inside the service",id:"running-a-task-inside-the-service-1",level:4},{value:"Retrieving data from the bound service",id:"retrieving-data-from-the-bound-service",level:4},{value:"Exercices",id:"exercices",level:3}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",mdxAdmonitionTitle:"mdxAdmonitionTitle",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"03---services",children:"03 - Services"})}),"\n",(0,t.jsx)(n.p,{children:"A Service is an application component that can perform long-running operations in the background. It does not provide a user interface. Once started, a service might continue running for some time, even after the user switches to another application."}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsx)(n.p,{children:"In Android, services (e.g., Service) by default run on the main thread, so any long-running or blocking task directly executed in onStartCommand() will freeze the UI and potentially cause an Application Not Responding (ANR) error."})}),"\n",(0,t.jsx)(n.p,{children:"A service is simply a component that can run in the background, even when the user is not interacting with your application, so you should create a service only if that is what you need. For example, a thread in an activity would be more useful displaying data periodically or continuously in the UI."}),"\n",(0,t.jsx)(n.h2,{id:"the-service-lifecycle",children:"The service lifecycle"}),"\n",(0,t.jsxs)(n.p,{children:["All services extend the ",(0,t.jsx)(n.code,{children:"Service"})," class. Depending on whether the service want to comunicate with other components the service can be bounded (data can be requested from the service) or unbounded. Below you have the the list of callback methods available in the ",(0,t.jsx)(n.code,{children:"Service"})," class which define the service lifecycle."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"service lifecyle",src:i(6011).A+"",width:"389",height:"507"})}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Callback Method"}),(0,t.jsx)(n.th,{children:"Purpose"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"onCreate()"}),(0,t.jsx)(n.td,{children:"Initialize resources required by the service. This is called only once during the service lifecycle."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"onStartCommand()"}),(0,t.jsx)(n.td,{children:"Handle the service start request. Perform tasks that need to run in the foreground or background."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"onBind()"}),(0,t.jsx)(n.td,{children:"Return an IBinder to allow the client to communicate with the service."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"onUnbind()"}),(0,t.jsx)(n.td,{children:"Perform cleanup for the service when no clients remain bound."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"onRebind()"}),(0,t.jsx)(n.td,{children:"Handle cases where clients return to a previously unbound service."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"onDestroy()"}),(0,t.jsx)(n.td,{children:"Clean up any remaining resources, stop threads, and save final states."})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"services-types",children:"Services types"}),"\n",(0,t.jsx)(n.h3,{id:"background-services",children:"Background services"}),"\n",(0,t.jsx)(n.p,{children:"A background service performs an operation that isn't directly noticed by the user. For example, if an app used a service to compact its storage, that would usually be a background service."}),"\n",(0,t.jsx)(n.h4,{id:"starting-a-background-service",children:"Starting a background service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val intent = Intent(this, BackgroundService::class.java)\nstartService(intent)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n    //start task...\n    return START_STICKY\n}\n"})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"onStartCommand()"})," has to return one of the following constants"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"START_NOT_STICKY"}),"\nIf the system kills the service after onStartCommand() returns, do not recreate the service unless there are pending intents to deliver."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"START_STICKY"}),"\nIf the system kills the service after onStartCommand() returns, recreate the service and call onStartCommand(), but do not redeliver the last intent."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"START_REDELIVER_INTENT"}),"\nIf the system kills the service after onStartCommand() returns, recreate the service and call onStartCommand() with the last intent that was delivered to the service."]}),"\n"]})]}),"\n",(0,t.jsx)(n.h4,{id:"stoping-a-background-service",children:"Stoping a background service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val intent = Intent(this, BackgroundService::class.java)\nstopService(intent)\n\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"OR"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"stopSelf()\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"+"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'override fun onDestroy() {\n    super.onDestroy()\n    //cleanup ...\n    Log.d(TAG, "Service stopped")\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"running-a-task-inside-the-service",children:"Running a task inside the service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'//task\nprivate fun startTask() {\n    Thread {\n        // do something...\n        Log.d("Task", "log progress")\n    }.start()\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"foreground-services",children:"Foreground services"}),"\n",(0,t.jsx)(n.p,{children:"A foreground service performs some operation that is noticeable to the user. For example, an audio app would use a foreground service to play an audio track. Foreground services must display a Notification. Foreground services continue running even when the user isn't interacting with the app."}),"\n",(0,t.jsx)(n.h4,{id:"starting-a-foreground-service",children:"Starting a foreground service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val intent = Intent(this, ForegroundService::class.java)\nstartService(intent)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\n\n   // define a channel for the notification\n   // this is used so that you can group the types of notifications you want to have in your app\n    val channelId = "ForegroundServiceChannel"\n    val channelName = "Foreground Service"\n\n    val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager\n    val channel = NotificationChannel(\n        channelId,\n        channelName,\n        NotificationManager.IMPORTANCE_HIGH\n    )\n    notificationManager.createNotificationChannel(channel)\n\n    //create a notification\n    val notification = Notification.Builder(this, channelId)\n        .setContentTitle("Notification title")\n        .setContentText("Content: $data")\n        .setSmallIcon(android.R.drawable.ic_notification_overlay)\n        .build()\n\n    //this is when the foreground service actually starts\n    startForeground(1, notification)\n\n    //start task ...\n    return START_STICKY\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"stoping-a-foreground-service",children:"Stoping a foreground service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val intent = Intent(this, ForegroundService::class.java)\nstopService(intent)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'override fun onDestroy() {\n    super.onDestroy()\n    //cleanup...\n    Log.d(TAG, "Service stopped")\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"updating-data-in-the-notification",children:"Updating data in the notification"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'//task\nprivate fun startTask() {\n    Thread {\n        while (taskRunning) {\n            //do something...\n            updateNotification()\n        }\n    }.start()\n}\n\nprivate fun updateNotification() {\n    val notification = Notification.Builder(this, "ForegroundServiceChannel")\n        .setContentTitle("Notification title")\n        .setContentText("Content: $data")\n        .setSmallIcon(android.R.drawable.ic_notification_overlay)\n        .build()\n\n    //use notification manager to pass the updated notification\n    val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager\n    notificationManager.notify(1, notification)\n}\n'})}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsx)(n.p,{children:"Aditional permissions need to be set in the AndroidManifest file"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<uses-permission android:name="android.permission.FOREGROUND_SERVICE" />\n<uses-permission android:name="android.permission.POST_NOTIFICATIONS" />\n'})}),(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"+"}),"  When you decleare the service, you need to specify the service type"]}),(0,t.jsx)(n.p,{children:"Example"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:' <service\n        android:name=".MyMediaPlaybackService"\n        android:foregroundServiceType="mediaPlayback"\n        android:exported="false">\n</service>\n'})}),(0,t.jsxs)(n.p,{children:["You can find other types of foreground services ",(0,t.jsx)(n.a,{href:"https://developer.android.com/develop/background-work/services/fg-service-types",children:"here"}),"."]})]}),"\n",(0,t.jsx)(n.h3,{id:"bound-services",children:"Bound services"}),"\n",(0,t.jsx)(n.p,{children:"A bound service offers a client-server interface that allows components to interact with the service, send requests, receive results, and even do so across processes with interprocess communication (IPC)."}),"\n",(0,t.jsx)(n.h4,{id:"preparing-bound-service",children:"Preparing bound service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"private var boundService: BoundService? = null\nprivate var isBound = false\n\nprivate val serviceConnection = object : ServiceConnection {\n    override fun onServiceConnected(name: ComponentName?, service: IBinder?) {\n        val binder = service as BoundService.ServiceBinder\n        boundService = binder.getService()\n        isBound = true\n    }\n\n    override fun onServiceDisconnected(name: ComponentName?) {\n        isBound = false\n        boundService = null\n    }\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'class BoundService : Service() {\n\n    private val binder = ServiceBinder()\n    private var data: String = ""\n    //...\n    inner class ServiceBinder : Binder() {\n            fun getService(): BoundService = this@BoundService\n    }\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"binding-a-service",children:"Binding a service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"val intent = Intent(this, BoundService::class.java)\nbindService(intent, serviceConnection, BIND_AUTO_CREATE)\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"override fun onBind(intent: Intent?): IBinder {\n    //call task\n    return binder\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"unbiding-a-service",children:"Unbiding a service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"if (isBound) {\n    unbindService(serviceConnection)\n    isBound = false\n}\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"override fun onUnbind(intent: Intent?): Boolean {\n    return super.onUnbind(intent)\n}\n\noverride fun onDestroy() {\n    //cleanup...\n    super.onDestroy()\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"running-a-task-inside-the-service-1",children:"Running a task inside the service"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'//task\nprivate fun startTask() {\n    Thread {\n        // do something...\n        // modify data...\n        Log.d("Task", "log progress")\n    }.start()\n}\n'})}),"\n",(0,t.jsx)(n.h4,{id:"retrieving-data-from-the-bound-service",children:"Retrieving data from the bound service"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Caller component side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:'val data = boundService?.getData() ?: "No data"\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Service side"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-kotlin",children:"fun getData(): String {\n    return data\n}\n"})}),"\n",(0,t.jsx)(n.h3,{id:"exercices",children:"Exercices"}),"\n",(0,t.jsxs)(n.p,{children:["Clone the ",(0,t.jsx)(n.a,{href:"https://github.com/UPB-FILS-MDAD/labTemplates",children:"lab repository"})," or dowload the ",(0,t.jsx)(n.a,{href:"https://github.com/UPB-FILS-MDAD/labTemplates/blob/main/Services03.zip",children:"project zip file"})," and import the project template into android studio. For each task you will have a series of TODOs."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The layout for the main activity is already created. All buttons have their ",(0,t.jsx)(n.code,{children:"onClickListeners"})," declared."]}),"\n",(0,t.jsx)(n.li,{children:"All services classes are already created."}),"\n"]})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"alt text",src:i(4002).A+"",width:"262",height:"466"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Using button [3], start the ",(0,t.jsx)(n.code,{children:"BackgroundCounterService"})," from the ",(0,t.jsx)(n.code,{children:"MainActvity"}),". Using button [4], stop the ",(0,t.jsx)(n.code,{children:"BackgroundService"})," from the ",(0,t.jsx)(n.code,{children:"MainActvity"}),". In this service create a function that counts every second indefinetly (use a simple while loop) and logs the value of the counter in the logcat.\nCall this function inside the ",(0,t.jsx)(n.code,{children:"onStartCommand"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Run the app and click button [3]. Notice what happends with the interface."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Fix the issue in task 1."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Use buttons [1] and [2] to start/stop the ",(0,t.jsx)(n.code,{children:"ForegroundService"}),". Create a similar counter function to the one in task 2. and use it to update each second a notification that shows the counter value."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Use buttons [5] and [6] to bind/unbind the ",(0,t.jsx)(n.code,{children:"QuoteFetchService"}),". Display the latest fetched quote in the MainActivity when button [7] is pressed."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsx)(n.mdxAdmonitionTitle,{}),(0,t.jsx)(n.p,{children:"Notice what happends if you press button [7], before button [6]."})]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},6011:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/service_lifecycle-7803aed271fcb18129c4091043d27e74.png"},4002:(e,n,i)=>{i.d(n,{A:()=>t});const t=i.p+"assets/images/uibuttons-93618d879db30f0ece00aa3cde2b8c09.png"},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>c});var t=i(6540);const r={},s=t.createContext(r);function a(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);